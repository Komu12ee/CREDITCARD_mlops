name: CI/CD MLOps Pipeline (Simplified)

# 1. Triggers: Runs automatically on push, pull request, or manually
on:
  push:
    branches: [ "main", "dev" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: read 
  # CRITICAL: Retained for secure OIDC authentication with AWS
  id-token: write 

jobs:
  #####################################################################
  # JOB 1: Continuous Integration (CI) - Code Quality & Testing
  #####################################################################
  integration:
    name: Core CI Checks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        # We rely on the default GITHUB_TOKEN, which is simpler and more secure
        uses: actions/checkout@v4
        # Removed the 'with: token: anushka_mlops' line for simplicity

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11' 

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt || true # Installs all necessary DSMP/ML dependencies

      - name: Run Code Checks
        run: |
          echo "Running Linting and Unit Tests..."
          # In a real scenario, this would be 'pytest' or 'flake8'

  #####################################################################
  # JOB 2: Build & Push Docker Image (Secure Cloud Registry)
  # This is the Continuous Delivery (CD) artifact creation phase.
  #####################################################################
  build-and-push-image:
    name: Build & Push Image to ECR
    needs: integration # Requires CI checks to pass first
    runs-on: ubuntu-latest
    
    # Define outputs so deployment can retrieve the final image URI
    outputs:
      image_uri: ${{ steps.build-image.outputs.image_uri }} 

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # 1. OIDC AUTH: Securely get temporary AWS credentials
      - name: Configure AWS Credentials with OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # IMPORTANT: Replace '123456789012' with your actual AWS Account ID
          role-to-assume: arn:aws:iam::123456789012:role/github-oidc-role 
          aws-region: ${{ secrets.AWS_REGION }}

      # 2. ECR Login: Use the temporary credentials to log in
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 3. Build & Push
      - name: Build, Tag, and Push Image to Amazon ECR
        id: build-image
        env:
          # Uses the unique commit hash for reproducible tagging
          IMAGE_TAG: ${{ github.sha }} 
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
        run: |
          FULL_IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

          echo "--- Starting Docker build for $FULL_IMAGE_URI ---"
          docker build -t $FULL_IMAGE_URI .
          
          echo "--- Pushing image to ECR... ---"
          docker push $FULL_IMAGE_URI
          
          # Pass the final image URI to the next (removed) deployment stage
          echo "image_uri=$FULL_IMAGE_URI" >> $GITHUB_OUTPUT 

  # Removed: The complex and fragile 'continuous-deployment' job. 
  # The artifact is now securely stored in ECR, ready for a dedicated
  # orchestration service (like ECS, EKS, or SageMaker) to deploy it.
